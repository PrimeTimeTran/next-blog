- Foundations
  - Big-O / Time & Space Complexity
  - Basic math (modular arithmetic, combinatorics) and problem patterns
- Arrays & Strings
  - Two Pointers
  - Sliding Window
  - Prefix / Suffix techniques
- Hashing
  - Hash tables / frequency maps
  - Sets
- Searching & Sorting
  - Binary Search (and variants)
    - Concepts:
      - Family A: Membership (hit-and-exit) binary search
        - l <= r
        - nums[m] == target? Exit
      - Family B: Boundary / candidate-elimination binary search
        - l < r
        - l & r pointers converge to a single index.
  - Common sorts (quick, merge, heap)
- Greedy Algorithms
- Stacks & Queues
  - Monotonic stack/queue
  - Deque
- Heaps / Priority Queues
- Linked Lists
- Trees
  - Binary Trees, Binary Search Trees
  - Tree traversals, recursion on trees
  - Tree problems (LCA, serialize/deserialize)
- Graphs
  - Representations (adj list/matrix)
  - BFS, DFS
  - Topological Sort
  - Union-Find (Disjoint Set)
  - Minimum Spanning Tree
  - Advanced graph algorithms (subtopics)
    - Dijkstra (single-source shortest path)
    - Bellman-Ford
    - Floyd-Warshall (all-pairs)
- Divide & Conquer
  - Examples: merge sort, quickselect, median of medians
- Backtracking
  - Permutations, combinations, subset generation
- Dynamic Programming
  - DP fundamentals (memoization vs bottom-up)
  - 1D DP (e.g., Fibonacci, climbing stairs)
  - 2D DP (e.g., LCS, matrix chain, subset sum variants)
  - Knapsack family
  - DP on trees, DP on intervals
- Bit Manipulation
- Advanced Data Structures
  - Tries
  - Segment Trees / Binary Indexed Trees (Fenwick)
  - Suffix Arrays / Trees (optional)
